# Raw Disk Cache 实现任务列表

## Phase 1: 基础实现 ✅ (已完成)

- [x] 1. 实现基础数据结构和类型
  - 实现 `DiskLocation` 结构体，包含校验和验证
  - 实现 `BlockHeader` 结构体和序列化
  - 定义常量（MAGIC_NUMBER, VERSION）
  - _已完成_

- [x] 2. 实现 Superblock 管理
  - 实现 `Superblock` 结构体
  - 实现 superblock 的加载和保存
  - 实现 superblock 验证
  - _已完成_

- [x] 3. 实现 Block Allocator
  - 实现基于位图的空间分配器
  - 实现 FirstFit/NextFit/BestFit 分配策略
  - 实现块的分配和释放
  - 实现空间统计
  - _已完成_

- [x] 4. 实现 Disk I/O Manager
  - 实现异步磁盘读写
  - 实现文件预分配
  - 实现数据对齐处理
  - 支持 Arc<Mutex<File>> 并发访问
  - _已完成_

- [x] 5. 实现 Cache Directory
  - 实现哈希索引 (HashMap)
  - 实现 LRU 队列管理
  - 实现基本的插入、查找、删除操作
  - 实现统计信息收集
  - _已完成_

- [x] 6. 实现 RawDiskCache 主结构
  - 整合所有组件
  - 实现 store/lookup/remove 操作
  - 实现基本的 GC 功能
  - 实现统计信息查询
  - _已完成_

- [x] 7. 编写基础测试
  - 单元测试：DiskLocation, BlockHeader
  - 单元测试：BlockAllocator
  - 单元测试：CacheDirectory
  - 集成测试：基本读写操作
  - 集成测试：多条目操作
  - 集成测试：大数据操作
  - 集成测试：GC 功能
  - _已完成_

## Phase 2: 元数据持久化和恢复

- [x] 1. 实现元数据序列化
  - 实现 CacheDirectory 的序列化/反序列化
  - 实现 BitVec 的高效序列化
  - 实现增量更新机制
  - _需求：元数据需要持久化到磁盘_

- [x] 2. 实现元数据持久化
  - 定期将元数据写入磁盘
  - 实现 checkpoint 机制
  - 实现元数据区域的管理
  - _需求：防止重启后元数据丢失_

- [x] 3. 实现崩溃恢复
  - 启动时加载元数据
  - 验证元数据完整性
  - 重建损坏的元数据
  - 扫描磁盘恢复缓存条目
  - _需求：系统崩溃后能恢复缓存_

- [x] 4. 编写恢复测试
  - 测试正常关闭和重启
  - 测试崩溃恢复
  - 测试元数据损坏恢复
  - _需求：验证恢复机制的正确性_

## Phase 3: 性能优化

- [x] 1. 实现 O_DIRECT 支持
  - 检测系统是否支持 O_DIRECT
  - 实现对齐的内存分配
  - 实现 O_DIRECT 读写
  - 性能对比测试
  - _需求：减少页缓存开销_

- [x] 2. 实现批量 I/O
  - 实现写入缓冲区
  - 实现批量提交机制
  - 实现批量读取优化
  - _需求：提高 I/O 吞吐量_

- [x] 3. 实现 io_uring 支持 (Linux)
  - 集成 io_uring 库
  - 实现异步批量 I/O
  - 实现队列深度配置
  - 性能测试和调优
  - _需求：最大化 I/O 性能_

- [x] 4. 实现预读取优化
  - 实现访问模式检测
  - 实现预读取策略
  - 实现预读取缓存
  - _需求：减少读取延迟_
  - _已完成_

- [x] 5. 实现零拷贝
  - 使用 sendfile 实现零拷贝传输
  - 使用 mmap 优化大文件访问
  - 性能测试
  - _需求：减少内存拷贝开销_

## Phase 4: 高级特性

- [x] 1. 实现智能 GC
  - 实现多种淘汰策略 (LRU, LFU, FIFO)
  - 实现自适应 GC 触发
  - 实现增量 GC
  - 实现 GC 性能监控
  - _需求：更高效的空间管理_

- [x] 2. 实现碎片整理
  - 实现碎片率检测
  - 实现在线碎片整理
  - 实现后台整理任务
  - _需求：保持高空间利用率_

- [x] 3. 实现 TTL 支持
  - 在 DiskLocation 中使用 timestamp
  - 实现过期检测
  - 实现自动清理过期数据
  - _需求：自动淘汰过期缓存_

- [x] 4. 实现数据压缩
  - 集成压缩库 (zstd/lz4)
  - 实现透明压缩/解压
  - 实现压缩率统计
  - _需求：提高空间利用率_
  - _已完成_

- [x] 5. 实现数据校验增强
  - 实现更强的校验算法 (xxhash)
  - 实现定期数据校验
  - 实现损坏数据自动修复
  - _需求：提高数据可靠性_

## Phase 5: 集成和配置

- [x] 1. 集成到 TieredCache
  - 修改 TieredCache 支持 RawDiskCache
  - 实现配置选项
  - 实现平滑切换
  - _需求：作为 L2 缓存使用_

- [x] 2. 实现配置管理
  - 添加 raw_disk 配置项到 SliceConfig
  - 实现配置验证
  - 实现配置热更新
  - _需求：灵活的配置选项_

- [x] 3. 实现监控指标
  - 导出 Prometheus 指标
  - 实现性能监控
  - 实现健康检查
  - _需求：运维可观测性_

- [ ] 4. 编写管理工具
  - 实现缓存查看工具
  - 实现缓存清理工具
  - 实现性能分析工具
  - _需求：方便运维管理_

## Phase 6: 测试和文档

- [ ] 1. 性能基准测试
  - 小文件读写性能测试
  - 大文件读写性能测试
  - 并发性能测试
  - 与文件系统方案对比
  - _需求：验证性能提升_

- [ ] 2. 压力测试
  - 长时间运行测试
  - 高并发压力测试
  - 内存泄漏检测
  - 崩溃恢复测试
  - _需求：验证稳定性_

- [x] 3. 编写使用文档
  - 配置指南
  - 性能调优指南
  - 故障排查指南
  - 最佳实践
  - _需求：用户友好_

- [ ] 4. 编写示例代码
  - 基本使用示例
  - 性能测试示例
  - 集成示例
  - _需求：快速上手_

## Phase 7: Pingora 框架集成（流式代理）

- [x] 1. 实现 Pingora ProxyHttp trait
  - 创建 StreamingProxy 结构体
  - 实现 new_ctx() 方法创建请求上下文
  - 实现 upstream_peer() 方法配置上游服务器
  - 实现基本的代理框架
  - _需求：使用 Pingora 框架实现流式代理_

- [x] 2. 实现请求过滤器
  - 实现 upstream_request_filter() 处理上游请求
  - 添加必要的请求头（Host, User-Agent 等）
  - 处理客户端 Range 请求
  - 实现请求日志记录
  - _需求：正确转发客户端请求到上游_

- [x] 3. 实现响应过滤器
  - 实现 response_filter() 处理响应头
  - 检查 Content-Length 和 Accept-Ranges
  - 决定是否启用缓存
  - 添加 X-Cache 响应头
  - _需求：处理上游响应头_

- [x] 4. 实现流式缓存
  - 实现 response_body_filter() 处理响应体
  - 边接收边转发数据块给客户端
  - 同时将数据块缓存到 TieredCache
  - 处理流结束标志 (end_of_stream)
  - _需求：实现边下载边返回，同时缓存_

- [x] 5. 实现缓存查找逻辑
  - 在 upstream_request_filter() 中检查缓存
  - 如果缓存命中，直接返回缓存内容
  - 如果缓存未命中，继续请求上游
  - 实现部分缓存命中的处理
  - _需求：优先使用缓存，减少上游请求_
  - _已完成_

- [x] 6. 实现错误处理
  - 处理上游连接失败
  - 处理上游超时
  - 处理缓存读写错误
  - 实现降级策略（缓存失败时仍然代理）
  - _需求：提高系统可靠性_

- [x] 7. 集成配置和监控
  - 从 SliceConfig 读取配置
  - 集成 TieredCache（支持 raw disk）
  - 添加 Prometheus 指标
  - 实现健康检查端点
  - _需求：生产环境可用_

- [x] 8. 编写集成测试
  - 测试流式下载（边下载边返回）
  - 测试缓存命中和未命中
  - 测试大文件代理（>100MB）
  - 测试并发请求
  - _需求：验证流式代理功能_

- [x] 9. 性能测试和优化
  - 对比流式代理 vs 简单代理的性能
  - 测试内存使用（应该保持稳定）
  - 测试首字节时间（TTFB）
  - 优化缓存写入性能
  - _需求：确保性能优势_

- [x] 10. 编写部署文档
  - Pingora 流式代理使用指南
  - 配置示例和最佳实践
  - 性能调优建议
  - 故障排查指南
  - _需求：方便用户部署_

## 当前状态

✅ **Phase 1 已完成** - 基础实现已经完成并通过所有测试
- 所有核心组件已实现
- 基本功能正常工作
- 测试覆盖率良好

🔄 **下一步**: Phase 2 - 元数据持久化和恢复

## 优先级说明

- **P0 (必须)**: Phase 1, Phase 2, Phase 5.1-5.2, Phase 7.1-7.5
- **P1 (重要)**: Phase 3.1-3.2, Phase 4.1, Phase 6.1-6.2, Phase 7.6-7.8
- **P2 (可选)**: Phase 3.3-3.5, Phase 4.2-4.5, Phase 5.3-5.4, Phase 7.9-7.10
- **P3 (未来)**: 其他优化和工具

## Phase 7 说明

Phase 7 是为了解决当前 `full_proxy_server.rs` 的核心问题：
- **问题**：缓存未命中时，等待整个文件下载完成才返回给客户端
- **解决**：使用 Pingora 框架实现流式代理，边下载边返回，同时缓存
- **优势**：
  - ✅ 客户端立即开始接收数据（低 TTFB）
  - ✅ 内存使用稳定（不需要缓存整个文件在内存）
  - ✅ 符合 HTTP 代理规范
  - ✅ 支持大文件代理（>1GB）
  - ✅ 生产环境可用
